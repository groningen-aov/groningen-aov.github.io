<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Batch Data Processing - Groningen AAD Calculator</title>
    <link rel="stylesheet" href="../style/pico.blue.min.css" />
    <link rel="stylesheet" href="../style/style.css" />
    <!-- PapaParse CDN for CSV processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  </head>
  <body>
    <main class="container">
      <nav>
        <ul>
          <li><strong>Groningen AOV Calculator</strong></li>
        </ul>
        <ul>
          <li><a href="/" class="contrast">Home</a></li>
          <li><a href="/about/" class="contrast">About</a></li>
          <li><a href="/test/" class="contrast">Test</a></li>
          <li><a href="/batch/" class="contrast">Batch</a></li>
        </ul>
      </nav>

      <h1>Batch Data Processing</h1>

      <!-- Online requirement notice -->
      <article>
        <header>Online Connection Required</header>
        <div id="modelStatus" class="status-loading">
          <span id="statusIndicator">⏳</span>
          <span id="statusText">Loading calculation model...</span>
        </div>
        <p>
          Batch processing requires an internet connection to load the CSV
          parsing library. For offline calculations, use the
          <a href="../">individual calculator</a>.
        </p>
      </article>

      <!-- Model Status -->

      <!-- Unified Input Section -->
      <article class="batch-input-container">
        <div class="format-requirements">
          <p>
            <strong>Required columns:</strong> sex, age, height, weight
            &nbsp;•&nbsp; <strong>Optional:</strong> aad
          </p>
          <div class="format-details">
            <strong>Expected formats:</strong>
            <ul>
              <li>
                <strong>Sex:</strong> M/F, Male/Female, or m/f (case
                insensitive)
              </li>
              <li>
                <strong>Age:</strong> In years (decimal values accepted, e.g.,
                0.003 for 1-day-old)
              </li>
              <li><strong>Height:</strong> In centimeters (cm)</li>
              <li><strong>Weight:</strong> In kilograms (kg)</li>
              <li>
                <strong>AAD:</strong> In millimeters (mm) - optional for Z-score
                analysis
              </li>
            </ul>
          </div>
          <small
            >Column order doesn't matter as long as headers are included. Paste
            directly from Excel, Google Sheets, or CSV files. Supports comma,
            tab, or semicolon delimited data.</small
          >
        </div>

        <!-- Primary Textarea Interface -->
        <div class="primary-input-section">
          <label for="csvInput">
            <strong>Data Input</strong>
            <small>Supports large datasets (10,000+ rows tested)</small>
          </label>
          <textarea
            id="csvInput"
            class="primary-textarea"
            placeholder="Paste your data here...

With Measured AAD (for Z-scores):
sex,age,height,weight,aad
male,40,170,70,22.5
female,25,165,55,19.1

Predictions Only (research mode):
sex,age,height,weight
male,40,170,70
female,25,165,55

Tab-delimited (from spreadsheets):
sex	age	height	weight	aad
male	40	170	70	22.5"
            oninput="updateDataFeedback()"
          ></textarea>

          <!-- Live Feedback Display -->
          <div id="dataFeedback" class="data-feedback">
            <div id="statusLine" class="feedback-line">
              Ready for data entry
            </div>
            <div id="detectionLine" class="feedback-line detection-info"></div>
          </div>

          <!-- Assistive Options -->
          <div class="assistive-options">
            <button
              type="button"
              onclick="document.getElementById('fileInput').click()"
              class="secondary outline"
            >
              Choose File
            </button>
            <button
              type="button"
              onclick="loadExample('csv')"
              class="secondary outline"
            >
              Load Example
            </button>
            <button
              type="button"
              onclick="clearData()"
              class="secondary outline"
            >
              Clear Data
            </button>
            <input
              type="file"
              id="fileInput"
              accept=".csv,.txt"
              onchange="handleFileUpload(event)"
              style="display: none"
            />
          </div>

          <!-- Single Action Button -->
          <div class="primary-action">
            <button
              class="submit-button"
              onclick="processData()"
              id="processBtn"
            >
              Process Data
            </button>
          </div>
        </div>
      </article>

      <!-- Processing Status with Pico Loading -->
      <article id="processingStatus" aria-busy="false" style="display: none">
        <div class="processing-header">
          <h3 id="processingTitle">Processing Batch Data...</h3>
          <button onclick="cancelProcessing()" class="secondary outline">
            Cancel
          </button>
        </div>

        <div id="progressContainer" class="progress-container">
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          <div id="progressText" class="progress-text">Preparing...</div>
        </div>

        <div id="processingDetails" class="processing-details">
          <small
            >Estimated time remaining:
            <span id="timeRemaining">Calculating...</span></small
          >
        </div>
      </article>

      <!-- Results Section -->
      <div id="resultsSection" class="results-container" style="display: none">
        <h3>Processing Complete</h3>

        <div id="resultsSummary" class="results-summary">
          <!-- Summary stats will be populated here -->
        </div>

        <div class="results-actions">
          <button onclick="copyTableToClipboard()" class="primary">
            Copy to Clipboard
          </button>
          <button onclick="downloadResults()" class="outline">
            Save CSV File
          </button>
          <button onclick="resetBatch()" class="secondary">
            Process New Batch
          </button>
        </div>

        <!-- Results Table -->
        <div id="resultsTable" class="results-preview">
          <small
            id="copyFormatHint"
            style="
              color: var(--pico-muted-color);
              margin-top: 1rem;
              display: block;
            "
          >
            Table can be copied to clipboard and pasted directly into
            spreadsheets.
          </small>
          <div id="allResultsTable" class="table-container">
            <!-- Results table will be populated here -->
          </div>
        </div>
      </div>

      <div id="status" class="status"></div>
    </main>
    <!-- Footer -->
    <footer class="container">
      <small>
        <p>
          <em
            >For clinical decision support only. Always verify with
            institutional protocols.</em
          >
        </p>
      </small>
    </footer>
    <script src="../js/version.js"></script>

    <script>
      // =============================================================================
      // GLOBAL STATE
      // =============================================================================
      let calculator = null;
      let isModelLoaded = false;
      let processingCancelled = false;
      let currentResults = null;
      let inputFormat = {
        source: "paste", // 'paste' or 'file'
        delimiter: ",", // ',', '\t', or ';'
        hasAAD: true, // whether input included measured AAD column
      };

      // Real validated test cases from /test/ - much better than made-up data!
      const exampleData = {
        csv: `sex,age,height,weight,aad
male,40,170,70,22.5
female,0.003,50,3,6.2
male,2,85,12,11.5
female,10,140,35,15.1
male,16,175,65,20.2
female,25,165,55,19.1
male,55,180,90,25.8
female,30,155,50,18.9`,

        tab: `sex	age	height	weight	aad
male	40	170	70	22.5
female	0.003	50	3	6.2
male	2	85	12	11.5
female	10	140	35	15.1
male	16	175	65	20.2
female	25	165	55	19.1
male	55	180	90	25.8
female	30	155	50	18.9`,

        // Version without measured AAD for researchers who just want predictions
        prediction_only_csv: `sex,age,height,weight
male,40,170,70
female,0.003,50,3
male,2,85,12
female,10,140,35
male,16,175,65
female,25,165,55
male,55,180,90
female,30,155,50`,
      };

      // =============================================================================
      // BATCH CALCULATION ENGINE
      // =============================================================================

      /**
       * Simple Results Calculator for batch processing
       * Adapted from the existing results-calculator.js
       */
      class BatchCalculator {
        constructor() {
          this.lookupData = null;
          this.isLoaded = false;
        }

        async loadModel() {
          try {
            console.log("Loading calculation model...");
            const response = await fetch("/data/groningen_aad_lookup.json");
            if (!response.ok) {
              throw new Error(`Failed to load model: ${response.status}`);
            }
            this.lookupData = await response.json();
            this.isLoaded = true;
            console.log("Model loaded successfully");
            return true;
          } catch (error) {
            console.error("Model loading failed:", error);
            throw error;
          }
        }

        findLowerIndex(vec, q) {
          const n = vec.length;
          if (q <= vec[0]) return 0;
          if (q >= vec[n - 1]) return n - 2;

          let left = 0;
          let right = n - 1;

          while (left < right - 1) {
            const mid = Math.floor((left + right) / 2);
            if (vec[mid] <= q) {
              left = mid;
            } else {
              right = mid;
            }
          }
          return left;
        }

        trilinearInterpolation(x, y, z, flatValues, xq, yq, zq, sq) {
          const nX = x.length;
          const nY = y.length;
          const nZ = z.length;

          const getValue = (i, j, k, s) => {
            const index = i + j * nX + k * nX * nY + s * nX * nY * nZ;
            return flatValues[index];
          };

          const i = this.findLowerIndex(x, xq);
          const j = this.findLowerIndex(y, yq);
          const k = this.findLowerIndex(z, zq);
          const s = sq;

          const i1 = Math.min(i + 1, nX - 1);
          const j1 = Math.min(j + 1, nY - 1);
          const k1 = Math.min(k + 1, nZ - 1);

          const x0 = x[i],
            x1 = x[i1];
          const y0 = y[j],
            y1 = y[j1];
          const z0 = z[k],
            z1 = z[k1];

          const xd = x1 - x0 !== 0 ? (xq - x0) / (x1 - x0) : 0;
          const yd = y1 - y0 !== 0 ? (yq - y0) / (y1 - y0) : 0;
          const zd = z1 - z0 !== 0 ? (zq - z0) / (z1 - z0) : 0;

          const c000 = getValue(i, j, k, s);
          const c100 = getValue(i1, j, k, s);
          const c010 = getValue(i, j1, k, s);
          const c110 = getValue(i1, j1, k, s);
          const c001 = getValue(i, j, k1, s);
          const c101 = getValue(i1, j, k1, s);
          const c011 = getValue(i, j1, k1, s);
          const c111 = getValue(i1, j1, k1, s);

          const c00 = c000 * (1 - xd) + c100 * xd;
          const c10 = c010 * (1 - xd) + c110 * xd;
          const c01 = c001 * (1 - xd) + c101 * xd;
          const c11 = c011 * (1 - xd) + c111 * xd;

          const c0 = c00 * (1 - yd) + c10 * yd;
          const c1 = c01 * (1 - yd) + c11 * yd;

          return c0 * (1 - zd) + c1 * zd;
        }

        calculateSinglePatient(age, weight, height, sex, measuredAAD = null) {
          if (!this.isLoaded) {
            throw new Error("Model not loaded");
          }

          const logWeight = Math.log(weight);
          const sqrtHeight = Math.sqrt(height);
          const logAge = Math.log(age + 1);
          const sexValue = sex.toLowerCase() === "male" ? 0 : 1;

          const xGrid = this.lookupData.grid_axes.log_weight;
          const yGrid = this.lookupData.grid_axes.sqrt_height;
          const zGrid = this.lookupData.grid_axes.log_age_plus_1;

          const meanAAD = this.trilinearInterpolation(
            xGrid,
            yGrid,
            zGrid,
            this.lookupData.predictions.mean_aad,
            logWeight,
            sqrtHeight,
            logAge,
            sexValue
          );

          const stdDev = this.trilinearInterpolation(
            xGrid,
            yGrid,
            zGrid,
            this.lookupData.predictions.std_dev,
            logWeight,
            sqrtHeight,
            logAge,
            sexValue
          );

          const result = {
            meanAAD: meanAAD,
            stdDev: stdDev,
            lowerBound: meanAAD - 2 * stdDev,
            upperBound: meanAAD + 2 * stdDev,
            zScore: null,
            hasMeasuredAAD: measuredAAD !== null && measuredAAD > 0,
          };

          if (measuredAAD && measuredAAD > 0) {
            result.zScore = (measuredAAD - meanAAD) / stdDev;
          }

          return result;
        }
      }

      // =============================================================================
      // INITIALIZATION
      // =============================================================================

      async function initializeCalculator() {
        try {
          calculator = new BatchCalculator();
          await calculator.loadModel();
          isModelLoaded = true;

          document.getElementById("statusIndicator").textContent = "✅";
          document.getElementById("statusText").textContent =
            "Model ready for batch processing";
          document.getElementById("modelStatus").className = "status-success";
        } catch (error) {
          console.error("Failed to initialize:", error);
          document.getElementById("statusIndicator").textContent = "❌";
          document.getElementById("statusText").textContent =
            "Model load failed";
          document.getElementById("modelStatus").className = "status-error";
          showStatus(
            "Failed to load calculation model. Please refresh the page.",
            "error"
          );
        }
      }

      // =============================================================================
      // CSV PROCESSING FUNCTIONS
      // =============================================================================

      function detectDelimiter(text) {
        const firstLine = text.split("\n")[0];
        if (!firstLine) return ",";

        const commaCount = (firstLine.match(/,/g) || []).length;
        const tabCount = (firstLine.match(/\t/g) || []).length;
        const semicolonCount = (firstLine.match(/;/g) || []).length;

        if (
          tabCount > 0 &&
          tabCount >= commaCount &&
          tabCount >= semicolonCount
        ) {
          return "\t";
        } else if (semicolonCount > commaCount) {
          return ";";
        } else {
          return ",";
        }
      }

      function validateAndCleanData(patients) {
        const errors = [];
        const cleanPatients = [];

        patients.forEach((patient, index) => {
          const rowNum = index + 1;
          const cleanPatient = {};

          // Clean and validate sex
          if (!patient.sex) {
            errors.push(`Row ${rowNum}: Missing sex value`);
            return;
          }
          const sex = patient.sex.toString().toLowerCase().trim();
          if (sex.startsWith("m")) {
            cleanPatient.sex = "male";
          } else if (sex.startsWith("f")) {
            cleanPatient.sex = "female";
          } else {
            errors.push(
              `Row ${rowNum}: Invalid sex "${patient.sex}" (use M/F or Male/Female)`
            );
            return;
          }

          // Clean and validate required numeric fields
          const requiredFields = ["age", "weight", "height"];
          for (const field of requiredFields) {
            const value = parseFloat(patient[field]);
            if (isNaN(value) || value <= 0) {
              errors.push(
                `Row ${rowNum}: Invalid ${field} "${patient[field]}" (must be positive number)`
              );
              return;
            }
            cleanPatient[field] = value;
          }

          // AAD is optional! Some researchers just want predictions
          if (
            patient.aad !== undefined &&
            patient.aad !== null &&
            patient.aad !== ""
          ) {
            const aadValue = parseFloat(patient.aad);
            if (isNaN(aadValue) || aadValue <= 0) {
              errors.push(
                `Row ${rowNum}: Invalid AAD "${patient.aad}" (must be positive number or leave blank)`
              );
              return;
            }
            cleanPatient.aad = aadValue;
          } else {
            cleanPatient.aad = null; // No measured AAD - just want predictions
          }

          // Validate ranges (based on model constraints)
          if (cleanPatient.age > 59) {
            errors.push(
              `Row ${rowNum}: Age ${cleanPatient.age} exceeds maximum (59 years)`
            );
            return;
          }
          if (cleanPatient.weight < 1.34 || cleanPatient.weight > 352) {
            errors.push(
              `Row ${rowNum}: Weight ${cleanPatient.weight}kg outside valid range (1.34-352kg)`
            );
            return;
          }
          if (cleanPatient.height < 30 || cleanPatient.height > 236) {
            errors.push(
              `Row ${rowNum}: Height ${cleanPatient.height}cm outside valid range (30-236cm)`
            );
            return;
          }

          cleanPatients.push(cleanPatient);
        });

        return { cleanPatients, errors };
      }

      async function processBatchOnMainThread(patients, progressCallback) {
        const results = [];
        // Dynamic chunk size: smaller chunks for tiny batches, larger for big ones
        const chunkSize =
          patients.length < 100
            ? Math.max(10, Math.ceil(patients.length / 5))
            : 100;
        const startTime = Date.now();

        for (let i = 0; i < patients.length; i += chunkSize) {
          if (processingCancelled) {
            throw new Error("Processing cancelled by user");
          }

          const chunk = patients.slice(i, i + chunkSize);

          // Process chunk
          for (const patient of chunk) {
            try {
              const calculation = calculator.calculateSinglePatient(
                patient.age,
                patient.weight,
                patient.height,
                patient.sex,
                patient.aad
              );

              results.push({
                ...patient,
                expectedAAD: calculation.meanAAD,
                stdDev: calculation.stdDev,
                lowerBound: calculation.lowerBound,
                upperBound: calculation.upperBound,
                zScore: calculation.zScore,
                hasMeasuredAAD: calculation.hasMeasuredAAD,
                status: "success",
              });
            } catch (error) {
              results.push({
                ...patient,
                error: error.message,
                status: "error",
              });
            }
          }

          // Update progress
          const processed = Math.min(i + chunkSize, patients.length);
          const progress = (processed / patients.length) * 100;
          const elapsed = Date.now() - startTime;
          const estimated = elapsed * (patients.length / processed) - elapsed;

          if (progressCallback) {
            progressCallback({
              processed,
              total: patients.length,
              progress,
              timeRemaining: estimated,
            });
          }

          // Brief pause to keep UI responsive (and show progress for small batches)
          if (i + chunkSize < patients.length) {
            await new Promise((resolve) => setTimeout(resolve, 1));
          }
        }

        return results;
      }

      // =============================================================================
      // PROFESSIONAL UI FUNCTIONS
      // =============================================================================

      function updateDataFeedback() {
        const input = document.getElementById("csvInput").value.trim();
        const statusLine = document.getElementById("statusLine");
        const detectionLine = document.getElementById("detectionLine");

        if (!input) {
          statusLine.textContent = "Ready for data entry";
          detectionLine.textContent = "";
          return;
        }

        const lines = input.split("\n").filter((line) => line.trim());
        const delimiter = detectDelimiter(input);

        let delimiterName;
        switch (delimiter) {
          case "\t":
            delimiterName = "Tab-delimited format detected";
            break;
          case ";":
            delimiterName = "Semicolon-delimited format detected";
            break;
          default:
            delimiterName = "Comma-delimited format detected";
        }

        const hasHeader = lines[0] && lines[0].toLowerCase().includes("sex");
        const dataRows = hasHeader ? lines.length - 1 : lines.length;

        // Check if AAD column is present
        const hasAAD = hasHeader && lines[0].toLowerCase().includes("aad");

        if (dataRows > 0) {
          statusLine.textContent = `${dataRows.toLocaleString()} rows detected - ready to process`;
          statusLine.className = "feedback-line success";

          const mode = hasAAD
            ? "with measured AAD for Z-score analysis"
            : "predictions only (research mode)";
          detectionLine.textContent = `${delimiterName} • ${mode}`;
          detectionLine.className = "feedback-line detection-info";
        } else {
          statusLine.textContent = "Invalid data format";
          statusLine.className = "feedback-line error";
          detectionLine.textContent = "";
        }
      }

      function loadExample(format = "csv") {
        const data = exampleData[format] || exampleData.csv;
        document.getElementById("csvInput").value = data;
        updateDataFeedback();

        showStatus("Sample research data loaded - ready to process.", "info");
      }

      function clearData() {
        document.getElementById("csvInput").value = "";
        document.getElementById("fileInput").value = "";
        updateDataFeedback();
        hideStatus();
        resetProcessingUI();
      }

      function showStatus(message, type) {
        const status = document.getElementById("status");
        status.textContent = message;
        status.className = `status ${type}`;
        status.style.display = "block";
      }

      function hideStatus() {
        document.getElementById("status").style.display = "none";
      }

      function resetProcessingUI() {
        const processingElement = document.getElementById("processingStatus");
        processingElement.style.display = "none";
        processingElement.setAttribute("aria-busy", "false");

        document.getElementById("resultsSection").style.display = "none";
        document.getElementById("processBtn").disabled = false;
        document.getElementById("processBtn").textContent = "Process Data";

        // Reset progress container visibility
        document.getElementById("progressContainer").style.display = "block";
        document.getElementById("processingDetails").style.display = "block";

        processingCancelled = false;
      }

      // =============================================================================
      // MAIN PROCESSING FUNCTIONS
      // =============================================================================

      async function processData() {
        if (!isModelLoaded) {
          showStatus(
            "Model not ready. Please wait for initialization.",
            "error"
          );
          return;
        }

        const textInput = document.getElementById("csvInput").value.trim();
        const fileInput = document.getElementById("fileInput").files[0];

        if (!textInput && !fileInput) {
          showStatus("Please enter data to process.", "error");
          return;
        }

        try {
          resetProcessingUI();
          let csvData = textInput;

          // Handle file input if provided
          if (fileInput && !textInput) {
            if (fileInput.size > 10 * 1024 * 1024) {
              showStatus("File too large. Maximum size is 10MB.", "error");
              return;
            }

            csvData = await readFileAsText(fileInput);
            document.getElementById("csvInput").value = csvData;
            updateDataFeedback();
          }

          // Parse CSV data and detect format
          const delimiter = detectDelimiter(csvData);
          inputFormat.delimiter = delimiter;
          inputFormat.source = fileInput && !textInput ? "file" : "paste";

          const parseResult = Papa.parse(csvData, {
            header: true,
            delimiter: delimiter,
            dynamicTyping: true,
            skipEmptyLines: true,
            transformHeader: (header) => header.trim().toLowerCase(),
          });

          if (parseResult.errors.length > 0) {
            console.warn("CSV parsing warnings:", parseResult.errors);
          }

          const patients = parseResult.data;
          if (patients.length === 0) {
            showStatus("No valid data rows found in input.", "error");
            return;
          }

          // Check for required columns - AAD is now optional!
          const requiredColumns = ["sex", "age", "height", "weight"];
          const availableColumns = Object.keys(patients[0] || {});
          const missingColumns = requiredColumns.filter(
            (col) => !availableColumns.includes(col)
          );

          if (missingColumns.length > 0) {
            showStatus(
              `Missing required columns: ${missingColumns.join(
                ", "
              )}. Required: sex, age, height, weight. Optional: aad`,
              "error"
            );
            return;
          }

          // Track whether input has AAD column
          inputFormat.hasAAD = availableColumns.includes("aad");

          // Validate and clean data
          const { cleanPatients, errors } = validateAndCleanData(patients);

          if (errors.length > 0) {
            const errorMsg =
              errors.slice(0, 5).join("\n") +
              (errors.length > 5
                ? `\n... and ${errors.length - 5} more errors`
                : "");
            showStatus(`Data validation errors:\n${errorMsg}`, "error");
            return;
          }

          if (cleanPatients.length === 0) {
            showStatus("No valid patients found after validation.", "error");
            return;
          }

          // Start processing
          await startBatchProcessing(cleanPatients);
        } catch (error) {
          console.error("Processing failed:", error);
          showStatus(`Processing failed: ${error.message}`, "error");
          resetProcessingUI();
        }
      }

      async function startBatchProcessing(patients) {
        const isLargeBatch = patients.length > 500;
        const startTime = Date.now();

        // Always show Pico loading spinner - it's beautiful and native!
        // Small batches: Just elegant spinner (300ms minimum for visibility)
        // Large batches: Spinner + detailed progress bar
        const processingElement = document.getElementById("processingStatus");
        const progressContainer = document.getElementById("progressContainer");
        const processingTitle = document.getElementById("processingTitle");

        processingElement.style.display = "block";
        processingElement.setAttribute("aria-busy", "true");

        if (isLargeBatch) {
          // Large batch: Show full progress UI with spinner
          processingTitle.textContent = "Processing Large Dataset...";
          progressContainer.style.display = "block";
          document.getElementById("processingDetails").style.display = "block";
        } else {
          // Small batch: Just show elegant Pico spinner
          processingTitle.textContent = `Processing ${patients.length.toLocaleString()} patients...`;
          progressContainer.style.display = "none";
          document.getElementById("processingDetails").style.display = "none";
        }

        hideStatus();

        const progressCallback = (progress) => {
          if (isLargeBatch) {
            const percentage = Math.round(progress.progress);
            document.getElementById(
              "progressFill"
            ).style.width = `${percentage}%`;
            document.getElementById(
              "progressText"
            ).textContent = `${progress.processed.toLocaleString()} of ${progress.total.toLocaleString()} patients processed (${percentage}%)`;

            if (progress.timeRemaining > 0) {
              const seconds = Math.ceil(progress.timeRemaining / 1000);
              document.getElementById(
                "timeRemaining"
              ).textContent = `${seconds} seconds`;
            }
          }
        };

        try {
          const results = await processBatchOnMainThread(
            patients,
            progressCallback
          );
          const processingTime = Date.now() - startTime;

          // For small batches, ensure the spinner is visible for at least 300ms
          if (!isLargeBatch && processingTime < 300) {
            await new Promise((resolve) =>
              setTimeout(resolve, 300 - processingTime)
            );
          }

          currentResults = results;
          showResults(results, processingTime);
        } catch (error) {
          showStatus(`Processing failed: ${error.message}`, "error");
          resetProcessingUI();
        }
      }

      function showResults(results, processingTime) {
        const processingElement = document.getElementById("processingStatus");
        processingElement.style.display = "none";
        processingElement.setAttribute("aria-busy", "false");

        document.getElementById("resultsSection").style.display = "block";

        const successful = results.filter((r) => r.status === "success").length;
        const failed = results.filter((r) => r.status === "error").length;
        const withAAD = results.filter(
          (r) => r.status === "success" && r.hasMeasuredAAD
        ).length;
        const outliers = results.filter(
          (r) => r.zScore && Math.abs(r.zScore) > 2
        ).length;

        // Performance messaging for professional confidence
        let timeMessage;
        if (processingTime < 100) {
          timeMessage = `${processingTime}ms processing time`;
        } else if (processingTime < 500) {
          timeMessage = `${processingTime}ms processing time`;
        } else {
          timeMessage = `${(processingTime / 1000).toFixed(
            1
          )}s processing time`;
        }

        let summaryHtml = `<div class="performance-badge">${timeMessage}</div>`;

        if (inputFormat.hasAAD && withAAD > 0) {
          // Show Z-score stats when we have measured AAD values
          summaryHtml += `
            <div class="summary-stats">
              <div class="stat-card">
                <div class="stat-number">${successful.toLocaleString()}</div>
                <div class="stat-label">Successfully Processed</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">${withAAD.toLocaleString()}</div>
                <div class="stat-label">With Measured AAD</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">${outliers}</div>
                <div class="stat-label">Outliers (|Z| > 2)</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">${failed}</div>
                <div class="stat-label">Failed</div>
              </div>
            </div>`;
        } else {
          // Show prediction-only stats
          summaryHtml += `
            <div class="summary-stats">
              <div class="stat-card">
                <div class="stat-number">${successful.toLocaleString()}</div>
                <div class="stat-label">Predictions Generated</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">${failed}</div>
                <div class="stat-label">Failed</div>
              </div>
              <div class="stat-card">
                <div class="stat-number">Research</div>
                <div class="stat-label">Mode</div>
              </div>
            </div>`;
        }

        document.getElementById("resultsSummary").innerHTML = summaryHtml;

        // Show full results table immediately
        showFullResultsTable();
      }

      function showFullResultsTable() {
        const allTable = document.getElementById("allResultsTable");
        const successful = currentResults.filter((r) => r.status === "success");

        // Limit display for large datasets to preserve browser memory
        const displayLimit = 500;
        const isLargeDataset = successful.length > displayLimit;
        const displayResults = isLargeDataset
          ? successful.slice(0, displayLimit)
          : successful;

        let html =
          '<div style="max-height: 500px; overflow: auto;"><table class="striped" id="mainResultsTable"><thead><tr>';
        html += "<th>Sex</th><th>Age</th><th>Height</th><th>Weight</th>";
        if (inputFormat.hasAAD) html += "<th>Measured AAD</th>";
        html += "<th>Expected AAD</th><th>Std Dev</th>";
        if (inputFormat.hasAAD) html += "<th>Z-Score</th>";
        html += "<th>Normal Range</th></tr></thead><tbody>";

        displayResults.forEach((result) => {
          html += "<tr>";
          html += `<td>${result.sex}</td>`;
          html += `<td>${result.age}</td>`;
          html += `<td>${result.height}</td>`;
          html += `<td>${result.weight}</td>`;

          if (inputFormat.hasAAD) {
            html += `<td>${result.aad ? result.aad.toFixed(1) : "—"}</td>`;
          }

          html += `<td><strong>${result.expectedAAD.toFixed(2)}</strong></td>`;
          html += `<td>${result.stdDev.toFixed(2)}</td>`;

          if (inputFormat.hasAAD) {
            const zScoreStyle =
              result.zScore && Math.abs(result.zScore) > 2
                ? 'style="color: var(--pico-del-color); font-weight: bold;"'
                : "";
            html += `<td ${zScoreStyle}>${
              result.zScore ? result.zScore.toFixed(2) : "—"
            }</td>`;
          }

          html += `<td>${result.lowerBound.toFixed(
            1
          )} - ${result.upperBound.toFixed(1)}</td>`;
          html += "</tr>";
        });

        html += "</tbody></table></div>";
        allTable.innerHTML = html;

        // Update hint for large datasets
        const copyHint = document.getElementById("copyFormatHint");
        if (isLargeDataset) {
          copyHint.innerHTML = `Showing first ${displayLimit.toLocaleString()} of ${successful.length.toLocaleString()} results to preserve browser memory. <strong>Use "Copy to Clipboard" or "Save CSV File" for complete dataset.</strong>`;
        } else {
          copyHint.textContent =
            "Table can be copied to clipboard and pasted directly into spreadsheets.";
        }
      }
      async function copyTableToClipboard() {
        try {
          const successful = currentResults.filter(
            (r) => r.status === "success"
          );
          const delimiter = inputFormat.delimiter;

          // Create header row
          let headers = ["sex", "age", "height", "weight"];
          if (inputFormat.hasAAD) headers.push("measured_aad");
          headers.push("expected_aad", "std_dev");
          if (inputFormat.hasAAD) headers.push("z_score");
          headers.push("lower_bound", "upper_bound");

          // Create data rows
          const rows = [headers.join(delimiter)];

          successful.forEach((result) => {
            let row = [result.sex, result.age, result.height, result.weight];

            if (inputFormat.hasAAD) {
              row.push(result.aad ? result.aad.toFixed(1) : "");
            }

            row.push(result.expectedAAD.toFixed(3), result.stdDev.toFixed(3));

            if (inputFormat.hasAAD) {
              row.push(result.zScore ? result.zScore.toFixed(3) : "");
            }

            row.push(
              result.lowerBound.toFixed(3),
              result.upperBound.toFixed(3)
            );

            rows.push(row.join(delimiter));
          });

          // Add citation header for research provenance
          const citationHeader = [
            "# Groningen AAD Calculator Results",
            "# Citation: [To be updated upon publication]",
            "# Calculator: https://groningen-aov.github.io",
            "# Generated: " + new Date().toISOString().split("T")[0],
            "#",
          ].join("\n");

          const tableText = citationHeader + "\n" + rows.join("\n");

          await navigator.clipboard.writeText(tableText);
          showStatus(
            "Table copied to clipboard - ready to paste into spreadsheets.",
            "success"
          );
        } catch (error) {
          showStatus(
            "Failed to copy to clipboard. Please try the Save CSV File option instead.",
            "error"
          );
        }
      }

      function downloadResults() {
        if (!currentResults) return;

        // Create headers based on input format
        let csvHeaders = ["sex", "age", "height", "weight"];
        if (inputFormat.hasAAD) csvHeaders.push("measured_aad");
        csvHeaders.push("expected_aad", "std_dev");
        if (inputFormat.hasAAD) csvHeaders.push("z_score");
        csvHeaders.push("lower_bound", "upper_bound", "status");

        const csvData = currentResults.map((result) => {
          if (result.status === "error") {
            let row = [
              result.sex || "",
              result.age || "",
              result.height || "",
              result.weight || "",
            ];
            if (inputFormat.hasAAD) row.push(result.aad || "");
            row.push("", "", "");
            if (inputFormat.hasAAD) row.push("");
            row.push("", "", "error: " + result.error);
            return row;
          }

          let row = [result.sex, result.age, result.height, result.weight];

          if (inputFormat.hasAAD) {
            row.push(result.aad ? result.aad.toFixed(1) : "");
          }

          row.push(result.expectedAAD.toFixed(3), result.stdDev.toFixed(3));

          if (inputFormat.hasAAD) {
            row.push(result.zScore ? result.zScore.toFixed(3) : "");
          }

          row.push(
            result.lowerBound.toFixed(3),
            result.upperBound.toFixed(3),
            result.status
          );

          return row;
        });

        // Create citation header for research provenance
        const citationHeader = [
          "# Groningen AAD Calculator - Batch Processing Results",
          "# Citation: [To be updated upon publication]",
          "# Calculator: https://groningen-aov.github.io",
          "# Generated: " + new Date().toISOString(),
          "# Processed: " +
            currentResults.length.toLocaleString() +
            " patients",
          "#",
        ];

        const csvContent = [
          ...citationHeader,
          csvHeaders.join(","),
          ...csvData.map((row) => row.join(",")),
        ].join("\n");

        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const mode = inputFormat.hasAAD ? "with_zscore" : "predictions_only";
        a.download = `groningen_aad_batch_${mode}_${
          new Date().toISOString().split("T")[0]
        }.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      function resetBatch() {
        // Clear results data
        currentResults = null;

        // Reset input format
        inputFormat = {
          source: "paste",
          delimiter: ",",
          hasAAD: true,
        };

        // Clear DOM content to free memory
        document.getElementById("allResultsTable").innerHTML = "";
        document.getElementById("copyFormatHint").textContent = "";

        resetProcessingUI();
        clearData();

        // Suggest garbage collection (helps with large datasets)
        if (window.gc) {
          window.gc();
        }
      }

      function cancelProcessing() {
        processingCancelled = true;
        showStatus("Processing cancelled by user.", "info");
        resetProcessingUI();
      }

      // =============================================================================
      // FILE HANDLING
      // =============================================================================

      function readFileAsText(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = reject;
          reader.readAsText(file);
        });
      }

      function handleFileUpload(event) {
        const file = event.target.files[0];
        if (file) {
          if (file.size > 10 * 1024 * 1024) {
            showStatus("File too large. Maximum size is 10MB.", "error");
            return;
          }

          readFileAsText(file)
            .then((content) => {
              document.getElementById("csvInput").value = content;
              updateDataFeedback();
              showStatus(
                `File loaded: ${file.name} (${(file.size / 1024).toFixed(
                  1
                )} KB)`,
                "info"
              );
            })
            .catch((error) => {
              showStatus("Failed to read file.", "error");
            });
        }
      }

      // =============================================================================
      // INITIALIZATION
      // =============================================================================

      document.addEventListener("DOMContentLoaded", () => {
        initializeCalculator();
      });
    </script>

    <style>
      /* Professional Medical Interface Styling */
      .batch-input-container {
        margin-bottom: 2rem;
      }

      .format-requirements {
        background: var(--pico-card-sectioning-background-color);
        padding: 1rem;
        border-radius: var(--pico-border-radius);
        margin-bottom: 1.5rem;
        border-left: 4px solid var(--pico-primary);
      }

      .format-details {
        margin: 0.75rem 0;
      }

      .format-details ul {
        margin: 0.5rem 0 0 1rem;
        padding-left: 0;
      }

      .format-details li {
        margin-bottom: 0.25rem;
        font-size: 0.9rem;
      }

      .primary-input-section {
        position: relative;
      }

      /* Primary Textarea - 70% Visual Weight */
      .primary-textarea {
        min-height: 200px;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.9rem;
        line-height: 1.4;
        resize: vertical;
        margin-bottom: 0.75rem;
        border: 2px solid var(--pico-form-element-border-color);
        transition: border-color var(--pico-transition);
      }

      .primary-textarea:focus {
        border-color: var(--pico-primary);
        box-shadow: 0 0 0 var(--pico-outline-width)
          var(--pico-form-element-focus-color);
      }

      /* Live Feedback System */
      .data-feedback {
        background: var(--pico-card-sectioning-background-color);
        padding: 0.75rem 1rem;
        border-radius: var(--pico-border-radius);
        margin-bottom: 1rem;
        border-left: 3px solid var(--pico-muted-border-color);
        font-size: 0.9rem;
      }

      .feedback-line {
        margin: 0.25rem 0;
        font-weight: 500;
      }

      .feedback-line.success {
        color: var(--pico-ins-color);
      }

      .feedback-line.error {
        color: var(--pico-del-color);
      }

      .detection-info {
        color: var(--pico-muted-color);
        font-size: 0.85rem;
      }

      /* Assistive Options - Secondary Visual Weight */
      .assistive-options {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
      }

      .assistive-options button {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
      }

      /* Primary Action Button */
      .primary-action {
        text-align: center;
      }

      .primary-action .submit-button {
        min-width: 200px;
        font-size: 1.1rem;
        font-weight: 600;
      }

      /* Status Indicators */
      .status-loading {
        padding: 1rem;
        background: var(--pico-card-background-color);
        border-radius: var(--pico-border-radius);
        margin-bottom: 1rem;
        text-align: center;
      }

      .status-success {
        background: var(--pico-ins-background-color);
        color: var(--pico-ins-color);
      }

      .status-error {
        background: var(--pico-del-background-color);
        color: var(--pico-del-color);
      }

      /* Processing Interface */
      .processing-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }

      .processing-header h3 {
        margin: 0;
      }

      .progress-container {
        margin-bottom: 1rem;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: var(--pico-muted-border-color);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 0.5rem;
      }

      .progress-fill {
        height: 100%;
        background: var(--pico-primary);
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-text {
        text-align: center;
        font-weight: 500;
      }

      .processing-details {
        text-align: center;
        color: var(--pico-muted-color);
      }

      /* Results Display */
      .results-container {
        background: var(--pico-card-background-color);
        padding: 1.5rem;
        border-radius: var(--pico-border-radius);
        margin: 1rem 0;
        border-top: 4px solid var(--pico-primary);
      }

      .results-summary {
        margin-bottom: 1.5rem;
      }

      .performance-badge {
        display: inline-block;
        background: var(--pico-primary);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: var(--pico-border-radius);
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 1rem;
      }

      .summary-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .stat-card {
        text-align: center;
        padding: 1rem;
        background: var(--pico-card-sectioning-background-color);
        border-radius: var(--pico-border-radius);
        border: 1px solid var(--pico-muted-border-color);
      }

      .stat-number {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--pico-primary);
        margin-bottom: 0.25rem;
      }

      .stat-label {
        font-size: 0.875rem;
        color: var(--pico-muted-color);
        font-weight: 500;
      }

      .results-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-bottom: 1rem;
      }

      .results-preview {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--pico-muted-border-color);
      }

      .table-container {
        overflow-x: auto;
        margin-top: 1rem;
      }

      /* Mobile Responsiveness */
      @media (max-width: 768px) {
        .results-actions {
          flex-direction: column;
        }

        .assistive-options {
          flex-direction: column;
        }

        .summary-stats {
          grid-template-columns: 1fr;
        }

        .processing-header {
          flex-direction: column;
          gap: 1rem;
          text-align: center;
        }

        .primary-textarea {
          min-height: 150px;
          font-size: 0.85rem;
        }
      }
    </style>
  </body>
</html>
